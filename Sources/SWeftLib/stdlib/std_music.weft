// std_music.weft - Standard library for music/audio synthesis
// Include with: #include "std_music.weft"

// ============================================================================
// CONSTANTS
// ============================================================================

pi.val = 3.14159265359
tau.val = 6.28318530718

// ============================================================================
// OSCILLATORS
// ============================================================================

// Sine wave at frequency f (Hz)
spindle sine(f) {
    return.0 = sin(me.t * f * 6.28318530718)
}

// Sawtooth wave (-1 to 1)
spindle saw(f) {
    return.0 = fract(me.t * f) * 2 - 1
}

// Square wave (-1 to 1)
spindle square(f) {
    return.0 = step(0.5, fract(me.t * f)) * 2 - 1
}

// Triangle wave (-1 to 1)
spindle tri(f) {
    return.0 = abs(fract(me.t * f) * 4 - 2) - 1
}

// Pulse wave with variable width (0-1)
spindle pulse(f, width) {
    return.0 = step(width, fract(me.t * f)) * 2 - 1
}

// Sine with phase offset (0-1)
spindle sinep(f, phase) {
    return.0 = sin((me.t * f + phase) * 6.28318530718)
}

// ============================================================================
// NOTE / FREQUENCY CONVERSION
// ============================================================================

// MIDI note to frequency (A4 = 69 = 440Hz)
spindle mtof(note) {
    return.0 = 440 * pow(2, (note - 69) / 12)
}


// Semitone offset to frequency ratio
spindle semi(n) {
    return.0 = pow(2, n / 12)
}

// ============================================================================
// TIMING / BEATS
// ============================================================================

// Beat phase (0-1 sawtooth) at given BPM
spindle beat(bpm) {
    return.0 = fract(me.t * bpm / 60)
}

// Current beat number (integer)
spindle beatNum(bpm) {
    return.0 = floor(me.t * bpm / 60)
}

// Subdivided beat phase (div=4 for 16th notes at given BPM)
spindle subdiv(bpm, div) {
    return.0 = fract(me.t * bpm / 60 * div)
}

// Step index for n-step pattern
spindle stepIdx(bpm, steps) {
    return.0 = mod(floor(me.t * bpm / 60 * steps), steps)
}

// Sample offset for retriggering samples each step
spindle stepOffset(bpm, steps) {
    phase.val = fract(me.t * bpm / 60 * steps)
    samples.val = me.sampleRate * 60 / bpm / steps
    return.0 = phase.val * samples.val
}

// Trigger pulse at beat start (width = fraction of beat, 0-1)
spindle btrig(bpm, width) {
    return.0 = 1 - step(width, fract(me.t * bpm / 60))
}

// ============================================================================
// ENVELOPES
// ============================================================================
// NOTE: Stateful envelopes need cache at the CALL SITE, not inside spindle.
// Pass the previous value as the last parameter.
//
// Usage pattern:
//   env.val = ar(gate.val, 0.001, 0.9999, cache(env.val, 2, 1, me.i))

// Attack-Release envelope
// attack = per-sample increment (e.g., 0.001)
// release = per-sample multiplier (e.g., 0.9999 for slow decay)
// prev = previous envelope value (use cache(output, 2, 1, me.i))
spindle ar(gate, attack, release, prev) {
    up.val = min(prev + attack, 1)
    down.val = prev * release
    return.0 = lerp(down.val, up.val, gate)
}

// Attack-Decay envelope (ignores gate after trigger)
// prev = previous value from cache
spindle ad(trig, attack, decay, prev) {
    // On trigger, reset to attack phase
    attacking.val = min(prev + attack, 1)
    decaying.val = prev * decay
    // Use max of triggered start or continued envelope
    return.0 = max(trig, lerp(decaying.val, attacking.val, prev < 1))
}

// Simple decay (multiply by rate each sample)
// Usage: env.val = edecay(0.9999, cache(env.val, 2, 1, me.i))
spindle edecay(rate, prev) {
    return.0 = prev * rate
}

// Retriggerable decay - resets to 1.0 on trigger
// Usage: env.val = tdecay(trig.val, 0.999, cache(env.val, 2, 1, me.i))
spindle tdecay(trig, rate, prev) {
    return.0 = lerp(prev * rate, 1, trig)
}

// ============================================================================
// FILTERS
// ============================================================================
// NOTE: Filters need cache at the CALL SITE.
//
// Usage pattern:
//   filtered.val = lpf(input.val, 1000, cache(filtered.val, 2, 1, me.i))

// One-pole lowpass filter
// freq = cutoff frequency in Hz
// prev = previous output (use cache)
spindle lpf(input, freq, prev) {
    alpha.val = 1 - pow(0.5, freq / me.sampleRate)
    return.0 = prev + alpha.val * (input - prev)
}

// One-pole highpass filter
// prev_out = previous output (use cache(output, 2, 1, me.i))
// prev_in = previous input (use cache(input, 2, 1, me.i))
spindle hpf(input, freq, prev_out, prev_in) {
    alpha.val = 1 / (1 + 6.28318 * freq / me.sampleRate)
    return.0 = alpha.val * (prev_out + input - prev_in)
}

// Attempt at resonant lowpass - needs two state variables
// s1, s2 = state from cache
// Usage:
//   filt.val = rlpf(in.val, 1000, 0.5, cache(st1.val, 2, 1, me.i), cache(st2.val, 2, 1, me.i))
//   st1.val = rlpf_s1(in.val, 1000, 0.5, cache(st1.val, 2, 1, me.i), cache(st2.val, 2, 1, me.i))
//   st2.val = filt.val
// (This is awkward - may need better pattern)
spindle rlpf(input, freq, res, s1, s2) {
    f.val = 2 * sin(3.14159 * freq / me.sampleRate)
    q.val = 1 - res
    hp.val = input - s1 - q.val * s2
    return.0 = s2 + f.val * s1  // lowpass output
}

// ============================================================================
// DELAY / EFFECTS
// ============================================================================

// Feedback delay - needs cache at call site
// samples = delay time in samples
// feedback = 0 to <1
// prev = cache(output, delay_samples, delay_samples, me.i)
//
// Usage:
//   delay_time.val = 12000  // quarter second at 48k
//   delayed.val = fbdelay(input.val, 0.6, cache(delayed.val, 48000, delay_time.val, me.i))
spindle fbdelay(input, feedback, delayed) {
    return.0 = input + delayed * feedback
}

// Simple delay (no feedback) - just use cache directly:
//   delayed.val = cache(input.val, 48000, delay_samples, me.i)

// Soft saturation / overdrive (stateless)
spindle saturate(input, drive) {
    x.val = input * drive
    return.0 = x.val / (1 + abs(x.val))
}

// Tanh saturation (warmer)
spindle tanh_sat(input, drive) {
    return.0 = (1 - pow(2.71828, -2 * input * drive)) / (1 + pow(2.71828, -2 * input * drive))
}

// Hard clip (stateless)
spindle clip(input, threshold) {
    return.0 = clamp(input, -threshold, threshold)
}

// Bitcrush - reduce bit depth (stateless)
spindle crush(input, bits) {
    levels.val = pow(2, bits)
    return.0 = floor(input * levels.val + 0.5) / levels.val
}

// ============================================================================
// TRIGGER / GATE UTILITIES
// ============================================================================

// Rising edge detector (1 on 0->1 transition)
// Usage: trig.val = rising(gate.val, cache(gate.val, 2, 1, me.i))
spindle rising(gate, prev_gate) {
    return.0 = gate * (1 - prev_gate)
}

// Falling edge detector (1 on 1->0 transition)
spindle falling(gate, prev_gate) {
    return.0 = (1 - gate) * prev_gate
}

// Sample and hold (sample input when trig goes high)
// Usage: held.val = sah(input.val, trig.val, cache(held.val, 2, 1, me.i), cache(trig.val, 2, 1, me.i))
spindle sah(input, trig, prev_out, prev_trig) {
    edge.val = trig * (1 - prev_trig)
    return.0 = lerp(prev_out, input, edge.val)
}

// Track and hold (follow input when gate high, hold when low)
// Usage: held.val = tah(input.val, gate.val, cache(held.val, 2, 1, me.i))
spindle tah(input, gate, prev) {
    return.0 = lerp(prev, input, gate)
}

// ============================================================================
// MIXING / UTILITIES (stateless)
// ============================================================================

// Crossfade between a and b (mix 0=a, 1=b)
spindle xfade(a, b, mix) {
    return.0 = lerp(a, b, mix)
}

// Equal power pan (mono to stereo, pan 0=left, 1=right)
spindle pan(mono, p) {
    return.0 = mono * sqrt(1 - p)
    return.1 = mono * sqrt(p)
}

// Mono to stereo (duplicate)
spindle m2s(mono) {
    return.0 = mono
    return.1 = mono
}

// Stereo to mono (average)
spindle s2m(left, right) {
    return.0 = (left + right) * 0.5
}

// dB to linear amplitude
spindle db2amp(db) {
    return.0 = pow(10, db / 20)
}


